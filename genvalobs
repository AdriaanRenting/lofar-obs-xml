#!/usr/bin/env python2
# -*- python -*-

import sys, copy
import ephem
import argparse
from momxml import Folder, SourceCatalogue, lofar_sidereal_time
from momxml import Stokes, TiedArrayBeams, BackendProcessing, Beam, Observation
from momxml import exclude_conflicting_eu_stations, station_list
from momxml import as_xml_mom_project
from momxml import SourceSpecificationError, InvalidStationSetError
from momxml import __version__


#
# Various messages
#

def prerror(message):
    """
    Print the string in *message* to standard error.
    """
    return sys.stderr.write('genvalobs error: '+message+'\n')


def print_short_help():
    """
    Print a short help message to standard output.
    """
    return sys.stdout.write('genvalobs: use "genvalobs --help" for help\n')



def parse_arguments():
    r'''
    Parse all command line arguments. Uses Python 2.7's argparse module.
    '''
    parser = argparse.ArgumentParser(
        description = '''
The (optional) source name must be enclosed in single or double
quotes if it contains spaces. The following sources are recommended:

- \"3C 48\"  /  48: LST 22:30--04:30
- \"3C 147\" / 147: LST 02:30--08:30
- \"3C 196\" / 196: LST 05:00--11:00
- \"3C 295\" / 295: LST 11:00--17:00
- \"Cyg A\"  / cyg: LST 16:00--24:00

If no source is specified, the program chooses the source that is
closest to the meridian at the central LST of the observing
sequence. The program has separate calibrator lists for LBA
and HBA observations and pulsars.
''', 
        formatter_class = argparse.RawDescriptionHelpFormatter)

    #usage='%(prog)s [options] \'source name\'')
    paa = parser.add_argument

    paa('-o', '--output', metavar='FILENAME',
        help    = 'Name of the output file.',
        default = ('lofar-validation-%04d%02d%02d-%02d%02d%02d.xml' %
                   ephem.Observer().date.tuple()))
    
    paa('-d', '--duration', metavar='SECONDS',
        help = 'Duration of individual observations in seconds.',
        type = int, default=120)

    paa('-g', '--gap', metavar='SECONDS',
        help = 'Gap between observations in seconds.',
        type = int, default=60)

    paa('-c', '--clocks', metavar='CLOCK_MHZ', action='append',
        choices = [160, 200],
        help    = '''Allowed clock frequencies. Choose 160 or 200. Option can be
provided multiple times if more than one clock frequency is
required.''',
        type=int, default=None)

    paa('-s', '--stations', metavar='STATION_SET',
        choices = ['superterp', 'core', 'remote', 'nl', 'europe', 'all', 'none'],
        help    = '''
One of superterp, core, remote, nl, europe, all, or none. EU stations
that conflict with certain HBA1 core fields are excluded from the
HBA_ONE, HBA_ONE_INNER, HBA_DUAL, and HBA_DUAL_INNER
observations. They are taken along in all other observations.''',
        default = 'nl')

    paa('-i', '--include', metavar='STATION_NAMES',
        help = 'Comma separated list of station names to include.')
    
    paa('-e', '--exclude', metavar='STATION_NAMES',
        help = 'Comma separated list of station names to exclude.')
    
    paa('-w', '--wait', metavar='SECONDS',
        help = 'Number of seconds to wait until the first observation.',
        type = int, default=540)

    paa('-t', '--start-date', metavar='DATE_STRING',
        help = '''Specify an exact date and time to start the first
        observation. Format: "yyyy/mm/dd hh:mm:ss.s''')
    
    paa('-p', '--project', metavar='MOM_NAME',
        help    = 'Name of the project under which the observations belong.',
        default = '2013LOFAROBS')

    paa('-m', '--mode', metavar='CORRELATOR_MODE',
        choices = ['XC', 'FE', 'CS', 'IS'], action='append',
        help    = '''
Correlator modes to test. Choose one of XC (crosscorrelation), FE
(Fly\'s eye), IS (incoherent stokes), or CS (coherent stokes). One can
specify more than one mode. If this argument is not spedified, all
modes will be tested.''',
        default = None)

    paa('-v', '--version', action='version',
        version = '%(prog)s ' +__version__+
        ' (c) 2010-2013 M.A. Brentjens <brentjens@astron.nl>')
    
    paa('source', nargs = '?',
        help = '''
Force a source to be used for all observations, bypassing genvalobs\'
own heuristics.''',
        default = None)

    args = parser.parse_args()
    if args.clocks is None:
        args.clocks = [200]

    if args.mode is None:
        args.mode = ['XC', 'FE', 'CS', 'IS']
    args.mode = [mode.upper() for mode in args.mode]
    return  args





def lookup_source(source_name=None):
    """
    Look up *source_name* in a table of standard calibrator
    sources. Raise a SourceSpecificationError if the source is not
    found. Otherwise, return a TargetSource object.
    """
    return SourceCatalogue().find_source(source_name)





def plan_observing_sequence(job_description):
    # Possible products:
    #  'XC'             , 'IS'             , 'CS'           , 'FE' for
    #  cross correlation, incoherent stokes, coherent stokes, Fly's eye
    full_schedule = [
        ['LBA_OUTER'     , 'LBA_LOW' , '12..499' , 200,  8, ['XC']],
        ['HBA_DUAL'      , 'HBA_LOW' , '12..499' , 200,  8, ['XC']],
        ['LBA_INNER'     , 'LBA_HIGH', '156..399', 200, 16, ['FE']],
        ['LBA_OUTER'     , 'LBA_HIGH', '156..399', 200, 16, ['FE']],
        ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['FE']],
        ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['IS']],
        ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['CS']],
        ['LBA_INNER'     , 'LBA_LOW' , '54..297' , 200, 16, ['XC']],
        ['LBA_OUTER'     , 'LBA_LOW' , '54..297' , 200, 16, ['XC']],
        ['LBA_INNER'     , 'LBA_HIGH', '156..399', 200, 16, ['XC']],
        ['LBA_OUTER'     , 'LBA_HIGH', '156..399', 200, 16, ['XC']],
        ['HBA_ZERO'      , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_ONE'       , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_DUAL_INNER', 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_JOINED'    , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_ZERO'      , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_ONE'       , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_DUAL'      , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_DUAL_INNER', 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_JOINED'    , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_ZERO'      , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
        ['HBA_ONE'       , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
        ['HBA_DUAL'      , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
        ['HBA_DUAL_INNER', 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
        ['HBA_JOINED'    , 'HBA_HIGH', '52..255' , 200, 16, ['XC']]]
    print job_description

    schedule      = [obs for obs in full_schedule
                     if obs[3] in job_description.clocks]
    now           = ephem.Observer().date
    start_date    = ephem.Date(now + ephem.second*job_description.wait)
    if job_description.start_date:
        start_date = job_description.start_date

    print 'LST at start observation: %s' % str(lofar_sidereal_time(start_date))

    mean_date     = (start_date +
                     ephem.second*len(schedule)*(job_description.duration +
                                                 job_description.gap)*0.5)

    mean_lst      = lofar_sidereal_time(mean_date)
    print 'Mean date: ' + repr(mean_date)
    print 'Mean LST: '+str(mean_lst)
    print 'Mean LST rad: %f' % float(mean_lst)

    include       = job_description.include
    include       = include and include.split(',')
    exclude       = job_description.exclude
    exclude       = exclude and exclude.split(',')
    stations      = station_list(job_description.stations,
                                 include = include,
                                 exclude = exclude,)
    observations  = []
    previous_clock = 200
    for (antenna_set,
         frequency_range,
         subband_spec,
         clock_mhz,
         bit_mode,
         data_products) in schedule:
        station_set   = copy.deepcopy(stations)
        target_source = job_description.source
        data_products = [data_product
                         for data_product in data_products
                         if data_product in job_description.mode]
        if len(data_products) == 0:
            continue # No data products to write, no point to observe.
        if target_source is None:
            if ('FE' in data_products 
                or 'CS' in data_products 
                or 'IS' in data_products):
                target_source = SourceCatalogue().psr_source(
                    mean_date, antenna_set[0:3])
            else:
                target_source = SourceCatalogue().cal_source(
                    mean_date, antenna_set[0:3])
        else:
            target_source = lookup_source(target_source)

        print ','.join(data_products) + ' ' + antenna_set
        print target_source
        # If clock switches, allow for two minutes extra
        if previous_clock != clock_mhz: 
            start_date = ephem.Date(start_date + 2*ephem.minute)

        channels_per_subband   = 64
        coherent_stokes_data   = None
        incoherent_stokes_data = None
        tied_array_beams       = None
        duration_seconds       = job_description.duration
        if 'FE' in data_products:
            channels_per_subband = 16
            coherent_stokes_data = Stokes('coherent',
                                          stokes_downsampling_steps = 128)
            tied_array_beams     = TiedArrayBeams(flyseye      = True,
                                                  beam_offsets = None)
            if 'LBA' == antenna_set[0:3]:
                duration_seconds = 600.0
        if 'CS' in data_products:
            coherent_stokes_data = Stokes('coherent',
                                          stokes_downsampling_steps = 128)
            if tied_array_beams is None:
                tied_array_beams = TiedArrayBeams(flyseye      = False,
                                                  beam_offsets = [(0.0, 0.0)])
            else:
                tied_array_beams.beam_offsets = [(0.0, 0.0)]
            core = set(station_list('core'))
            station_set = set(station_set).intersection(core)
        if 'IS' in data_products:
            incoherent_stokes_data = Stokes('incoherent',
                                            stokes_downsampling_steps = 128)
            
        good_stations = sorted(list(station_set))
        antenna_sets_with_conflicts = [
            'HBA_ONE', 'HBA_DUAL', 'HBA_ONE_INNER', 'HBA_DUAL_INNER']
        if antenna_set in antenna_sets_with_conflicts:
            good_stations = exclude_conflicting_eu_stations(good_stations)

        backend = BackendProcessing(
            integration_time_seconds = 1,
            correlated_data          = 'XC' in data_products,
            channels_per_subband     = channels_per_subband,
            coherent_stokes_data     = coherent_stokes_data,
            incoherent_stokes_data   = incoherent_stokes_data,
            tied_array_beams         = tied_array_beams)
        
        observations.append(Observation(
            name                     = ','.join(data_products)+' '+antenna_set,
            antenna_set              = antenna_set,
            frequency_range          = frequency_range,
            start_date               = start_date.tuple(),
            duration_seconds         = duration_seconds,
            stations                 = good_stations,
            clock_mhz                = clock_mhz,
            backend                  = backend,
            bit_mode                 = bit_mode,
            beam_list=[Beam(
                target_source            = target_source,
                subband_spec             = subband_spec)]))
        start_date = ephem.Date(start_date
                                + ephem.second*duration_seconds
                                + ephem.second*job_description.gap)
        previous_clock = clock_mhz
    return observations






def main():
    print parse_arguments()
    job_description = parse_arguments()

    observations = plan_observing_sequence(job_description)
    folder_date  = observations[0].start_date
    
    sub_folder     = Folder(
        name        =  '%04d-%02d-%02d %02d:%02d' % folder_date[:-1],
        description = ('Validation observations %04d-%02d-%02d %02d:%02d' %
                       folder_date[:-1]),
        children    = observations)
    val_obs_folder = Folder(name     = 'Validation Obs',
                            mom_id   = 192732,
                            children = [sub_folder])
    out = open(job_description.output, 'w')
    out.write(as_xml_mom_project([val_obs_folder],
                                 project = job_description.project))
    out.close()

    return 0





if __name__ == '__main__':
    try:
        print 'Current LST: '+str(lofar_sidereal_time(ephem.Observer().date))
        exit(main())
    except (OSError, IOError, SourceSpecificationError, InvalidStationSetError):
        prerror(sys.exc_info()[1].args[0])
        print_short_help()
        exit(-1)
