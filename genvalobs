#!/usr/bin/env python2
# -*- python -*-

import os, sys
from getopt import gnu_getopt as getopt
from getopt import GetoptError
import ephem
import argparse
from math import pi
from momxml import *
from momxml import __version__


#
# Various messages
#


def print_version():
    """
    Print version info to standard output
    """
    return sys.stdout.write('genvalobs version %s (c) 2010-2012 Michiel Brentjens <brentjens@astron.nl>\n' % __version__)


def prerror(message):
    """
    Print the string in *message* to standard error.
    """
    return sys.stderr.write('genvalobs error: '+message+'\n')


def print_short_help():
    """
    Print a short help message to standard output.
    """
    return sys.stdout.write('genvalobs: use "genvalobs --help" for help\n')



def parse_arguments():
    r'''
    '''
    parser = argparse.ArgumentParser()
    #usage='%(prog)s [options] \'source name\'')
    

    parser.add_argument('-o', '--output', metavar='FILENAME',
                        help='Name of the output file.',
                        default='lofar-validation-%04d%02d%02d-%02d%02d%02d.xml' % ephem.Observer().date.tuple())
    
    parser.add_argument('-d', '--duration', metavar='SECONDS',
                        help='Duration of individual observations in seconds.',
                        type=int, default=120)

    parser.add_argument('-g', '--gap', metavar='SECONDS',
                        help='Gap between observations in seconds.',
                        type=int, default=60)

    parser.add_argument('-c', '--clocks', metavar='CLOCK_MHZ', action='append',
                        choices = [160, 200],
                        help='Allowed clock frequencies. Choose 160 or 200. Option can be provided multiple times if more than one clock frequency is required.',
                        type=int, default=None)

    parser.add_argument('-s', '--stations', metavar='STATION_SET',
                        choices=['superterp', 'core', 'remote', 'nl', 'europe', 'all', 'none'],
                        help='''One of superterp, core, remote, nl, europe, all, or none. EU stations
that conflict with certain HBA1 core fields are excluded from the
HBA_ONE, HBA_ONE_INNER, HBA_DUAL, and HBA_DUAL_INNER
observations. They are taken along in all other observations.''',
                        default='nl')

    parser.add_argument('-i', '--include', metavar='STATION_NAMES',
                        help='Comma separated list of station names to add to station set.')

    parser.add_argument('-e', '--exclude', metavar='STATION_NAMES',
                        help='Comma separated list of station names to exclude from the station set.')

    parser.add_argument('-w', '--wait', metavar='SECONDS',
                        help='Number of seconds to wait until the first observation must begin.',
                        type=int, default=540)

    parser.add_argument('-t', '--start-date', metavar='DATE_STRING',
                        help='''Specify an exact date and time to start the first
                        observation. Format: "yyyy/mm/dd hh:mm:ss.s''')
    
    parser.add_argument('-p', '--project', metavar='MOM_NAME',
                        help='Name of the project under which the observations belong.',
                        default='2013LOFAROBS')

    parser.add_argument('-m', '--mode', metavar='CORRELATOR_MODE',
                        choices=['XC', 'FE', 'CS', 'IS'], action='append',
                        help='Correlator modes to test. Choose one of XC (crosscorrelation), FE (Fly\'s eye), IS (incoherent stokes), or CS (coherent stokes). One can specify more than one mode. If this argument is not spedified, all modes will be tested.',
                        default=None)
                        

    parser.add_argument('source', nargs = '?', help='''
The source name must be enclosed in single or double quotes if it contains spaces. The following sources are recommended:\n
\n
- \"3C 48\"  /  48: LST 22:30--04:30\n
- \"3C 147\" / 147: LST 02:30--08:30\n
- \"3C 196\" / 196: LST 05:00--11:00\n
- \"3C 295\" / 295: LST 11:00--17:00\n
- \"Cyg A\"  / cyg: LST 16:00--24:00\n
\n
If no source is specified, the program chooses the source that is closest to the meridian at the central LST of the observing sequence. The program has separate calibrator lists for LBA and HBA observations.
        ''',
                        default=None)
    args = parser.parse_args()
    if args.clocks is None:
        args.clocks=[200]

    if args.mode is None:
        args.mode=['XC', 'FE', 'CS', 'IS']
    return  args





def lookup_source(source_name=None):
    """
    Look up *source_name* in a table of standard calibrator
    sources. Raise a SourceSpecificationError if the source is not
    found. Otherwise, return a TargetSource object.
    """
    return SourceCatalogue().find_source(source_name)





def plan_observing_sequence(job_description):
    # Possible products:
    #  'XC', 'IS', 'CS', 'FE' for cross cor, incoherent stokes, coherent stokes, Fly's eye
    full_schedule = [['LBA_OUTER'     , 'LBA_LOW' , '12..499' , 200,  8, ['XC']],
                     ['HBA_DUAL'      , 'HBA_LOW' , '12..499' , 200,  8, ['XC']],
                     ['LBA_INNER'     , 'LBA_HIGH', '156..399', 200, 16, ['FE']],
                     ['LBA_OUTER'     , 'LBA_HIGH', '156..399', 200, 16, ['FE']],
                     ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['FE']],
                     ['LBA_INNER'     , 'LBA_LOW' , '54..297' , 200, 16, ['XC']],
                     ['LBA_OUTER'     , 'LBA_LOW' , '54..297' , 200, 16, ['XC']],
                     ['LBA_INNER'     , 'LBA_HIGH', '156..399', 200, 16, ['XC']],
                     ['LBA_OUTER'     , 'LBA_HIGH', '156..399', 200, 16, ['XC']],
                     ['HBA_ZERO'      , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
                     ['HBA_ONE'       , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
                     ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
                     ['HBA_DUAL_INNER', 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
                     ['HBA_JOINED'    , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
                     ['HBA_ZERO'      , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
                     ['HBA_ONE'       , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
                     ['HBA_DUAL'      , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
                     ['HBA_DUAL_INNER', 'HBA_MID' , '66..309' , 160, 16, ['XC']],
                     ['HBA_JOINED'    , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
                     ['HBA_ZERO'      , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
                     ['HBA_ONE'       , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
                     ['HBA_DUAL'      , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
                     ['HBA_DUAL_INNER', 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
                     ['HBA_JOINED'    , 'HBA_HIGH', '52..255' , 200, 16, ['XC']]
                     ]
    print job_description

    schedule      = [obs for obs in full_schedule if obs[3] in job_description.clocks]
    now           = ephem.Observer().date
    start_date    = ephem.Date(now + ephem.second*job_description.wait)
    if job_description.start_date:
        start_date = job_description.start_date

    print 'LST at start observation: %s' % str(lofar_sidereal_time(start_date))

    mean_date     = (start_date +
                     ephem.second*len(schedule)*(job_description.duration +
                                                 job_description.gap)*0.5)

    mean_lst      = lofar_sidereal_time(mean_date)
    print 'Mean date: ' + repr(mean_date)
    print 'Mean LST: '+str(mean_lst)
    print 'Mean LST rad: %f' % float(mean_lst)

    include       = job_description.include
    include       = include and include.split(',')
    exclude       = job_description.exclude
    exclude       = exclude and exclude.split(',')
    stations      = station_list(job_description.stations,
                                 include = include,
                                 exclude = exclude,)
    observations  = []
    previous_clock=200
    for antenna_set, frequency_range, subband_spec, clock_mhz, bit_mode, data_products in schedule:
        target_source = job_description.source
        data_products = [data_product
                         for data_product in data_products
                         if data_product in job_description.mode]
        if len(data_products) == 0:
            continue # No data products to write, no point to observe.
        if target_source is None:
            if 'FE' in data_products or 'CS' in data_products or 'IS' in data_products:
                target_source = SourceCatalogue().psr_source(mean_date, antenna_set[0:3])
            else:
                target_source = SourceCatalogue().cal_source(mean_date, antenna_set[0:3])
        else:
            target_source = lookup_source(target_source)

        print ','.join(data_products) + ' ' + antenna_set
        print target_source
        if previous_clock != clock_mhz: # If clock switches, allow for two minutes extra
            start_date = ephem.Date(start_date + 2*ephem.minute)
        good_stations = stations
        if antenna_set in ['HBA_ONE', 'HBA_DUAL', 'HBA_ONE_INNER', 'HBA_DUAL_INNER']:
            good_stations = exclude_conflicting_eu_stations(good_stations)

        channels_per_subband = 64
        coherent_stokes_data = None
        tied_array_beams     = None
        duration_seconds     = job_description.duration
        if 'FE' in data_products:
            channels_per_subband = 16
            coherent_stokes_data = Stokes('coherent',
                                          stokes_downsampling_steps = 128)
            tied_array_beams     = TiedArrayBeams(flyseye = True, beam_offsets=None)
            if 'LBA' == antenna_set[0:3]:
                duration_seconds = 600.0


        backend = BackendProcessing(
            integration_time_seconds = 1,
            correlated_data          = 'XC' in data_products,
            channels_per_subband     = channels_per_subband,
            coherent_stokes_data     = coherent_stokes_data,
            tied_array_beams         = tied_array_beams)
        
        observations.append(Observation(
            name                     = ','.join(data_products) + ' ' + antenna_set,
            antenna_set              = antenna_set,
            frequency_range          = frequency_range,
            start_date               = start_date.tuple(),
            duration_seconds         = duration_seconds,
            stations                 = good_stations,
            clock_mhz                = clock_mhz,
            backend                  = backend,
            bit_mode                 = bit_mode,
            beam_list=[Beam(
                target_source            = target_source,
                subband_spec             = subband_spec)]))
        start_date = ephem.Date(start_date
                                + ephem.second*duration_seconds
                                + ephem.second*job_description.gap)
        previous_clock=clock_mhz
        pass
    return observations






def main(argv):
    print parse_arguments()
    job_description = parse_arguments()#JobDescription(sys.argv, output='lofar-validation-%04d%02d%02d-%02d%02d%02d.xml' % ephem.Observer().date.tuple())

    observations = plan_observing_sequence(job_description)
    folder_date  = observations[0].start_date
    
    sub_folder     = Folder(name =  '%04d-%02d-%02d %02d:%02d' % folder_date[:-1],
                            description = 'Validation observations %04d-%02d-%02d %02d:%02d' % folder_date[:-1],
                            children    = observations)
    val_obs_folder = Folder(name = 'Validation Obs', mom_id=192732,
                            children = [sub_folder])
    out=open(job_description.output, 'w')
    out.write(as_xml_mom_project([val_obs_folder], project=job_description.project))
    out.close()

    return 0





if __name__ == '__main__':
    try:
        print_version()
        print 'Current LST: '+str(lofar_sidereal_time(ephem.Observer().date))
        exit(main(sys.argv))
    except (OSError, IOError, GetoptError, SourceSpecificationError, InvalidStationSetError):
        prerror(sys.exc_info()[1].args[0])
        print_short_help()
        exit(-1)
