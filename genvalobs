#!/usr/bin/env python

import os,sys
from getopt import gnu_getopt as getopt
from getopt import GetoptError
import ephem
from math import pi
from momxml import *


#
# Various messages
#


def print_version():
    """
    Print version info to standard output
    """
    return sys.stdout.write('genvalobs version 0.1 (c) 2010 Michiel Brentjens <brentjens@astron.nl>\n')


def prerror(message):
    """
    Print the string in *message* to standard error.
    """
    return sys.stderr.write('genvalobs error: '+message+'\n')


def print_short_help():
    """
    Print a short help message to standard output.
    """
    return sys.stdout.write('genvalobs: use "genvalobs --help" for help\n')


def print_manual():
    """
    Print basic manual to standard output.
    """
    return sys.stdout.write("""
usage: genvalobs [options] \"source name\"

The source name must be enclosed in single or double quotes if it
contains spaces. The following sources are supported:

- \"Cas A\"  / cas: LST 21:00--03:00
- \"3C 123\" / 123: LST 01:30--07:30
- \"3C 196\" / 196: LST 05:00--11:00
- \"Vir A\"  / vir: LST 09:30--15:30
- \"Her A\"  / her: LST 14:00--20:00
- \"Cyg A\"  / cyg: LST 16:00--24:00

Options:
-o / --output    Name of the output file. Default is
                 lofar-validation-yyyymmdd-hhmmss.xml

-d / --duration  Duration of individual observations in
                 seconds. Default is 180.

-g / --gap       Gap between observations in seconds. Default
                 is 180.

-s / --stations  Station set. One of: superterp, core, remote, nl,
                 europe, all. Default is nl.

-i / --include   Comma separated list of station names to add to
                 station set.

-e / --exclude   Comma separated list of stations to exlude from
                 station set.                 

-h / --help      Display manual.

""")



def lookup_source(source_name=None):
    """
    Look up *source_name* in a table of standard calibrator
    sources. Raise a SourceSpecificationError if the source is not
    found. Otherwise, return a TargetSource object.
    """
    return SourceCatalogue().find_source(source_name)










#
#  JobDescription
#

class JobDescription:
    """
    The JobDescription class is responsible for commandline
    parsing. Its data members are the program settings. One can
    specify default values when the object is constructed. Example
    usage:
    
    >>> job = JobDescription(sys.argv, duration=200)
    """
    
    def __init__(self, argv, output='schedule.log', duration_seconds=180, gap_seconds=180, target_source=None, print_help=False, station_set='nl',
                 include_list=[], exclude_list=[]):
        """
        Set default values and call parse_commandline(argv)
        """
        self.output                = output
        self.duration_seconds      = duration_seconds
        self.gap_seconds           = gap_seconds
        self.target_source         = target_source
        self.print_help            = print_help
        self.station_set           = station_set
        self.exclude_list          = exclude_list
        self.include_list          = include_list
        self.parse_commandline(argv)
        pass
    

    def parse_commandline(self, argv):
        """
        Parse the commandline passed in *argv*. Returns reference to
        self. May raise a GetoptError in case of commandline parsing
        problems.
        """
        options,args = getopt(argv[1:], 'o:d:i:e:s:g:h',
                              ['output=',
                               'duration=',
                               'include=',
                               'exclude=',
                               'stations=',
                               'gap=',
                               'help'])
        for (option, value) in options:
            if option in ['-o', '--output']:
                self.output = value
                
            elif option in ['-d', '--duration']:
                self.duration_seconds = int(value)
                
            elif option in ['-g', '--gap']:
                self.gap_seconds = int(value)
                
            elif  option in ['-s', '--stations']:
                self.station_set = value
                
            elif  option in ['-i', '--include']:
                self.include_list = value.upper().split(',')
                
            elif  option in ['-e', '--exclude']:
                self.exclude_list = value.upper().split(',')
                
            elif option in ['-h', '--help']:
                self.print_help = True
                return self
            pass # end of for loop

        if len(args) > 1:
            raise GetoptError('Although you may specify at most 1 target source, you specified %d, namely %s'%(len(args), str(args)))
        elif len(args) == 1:
            self.target_source = lookup_source(args[0])
        else:
            self.target_source = None
        return self


def plan_observing_sequence(job_description):
    schedule = [['LBA_INNER'  , 'LBA_LOW' , '52..299' , 200],
                ['LBA_OUTER'  , 'LBA_LOW' , '52..299' , 200],
                ['LBA_INNER'  , 'LBA_HIGH', '154..401', 200],
                ['LBA_OUTER'  , 'LBA_HIGH', '154..401', 200],
                ['HBA_ZERO'   , 'HBA_LOW' , '77..324' , 200],
                ['HBA_ONE'    , 'HBA_LOW' , '77..324' , 200],
                ['HBA_DUAL'   , 'HBA_LOW' , '77..324' , 200],
                ['HBA_JOINED' , 'HBA_LOW' , '77..324' , 200],
                ['HBA_ZERO'   , 'HBA_MID' , '64..311' , 160],
                ['HBA_ONE'    , 'HBA_MID' , '64..311' , 160],
                ['HBA_DUAL'   , 'HBA_MID' , '64..311' , 160],
                ['HBA_JOINED' , 'HBA_MID' , '64..311' , 160]
                ]
    now           = ephem.Observer().date
    start_date    = ephem.Date(now + ephem.minute*10)
    target_source = job_description.target_source
    if target_source is None:
        target_source = SourceCatalogue().closest_to_meridian(lofar_current_sidereal_time() + ephem.second*len(schedule)*(job_description.duration_seconds +job_description.gap_seconds)*0.5)
        pass
    stations      = get_station_list(job_description.station_set,
                                     job_description.include_list,
                                     job_description.exclude_list)
    observations  = []
    previous_clock=200
    for antenna_set, frequency_range, subband_spec, clock_mhz in schedule:
        if previous_clock != clock_mhz: # If clock switches, allow for one minute extra
            start_date = ephem.Date(start_date + ephem.minute)
            pass
        observations.append(Observation(
            target_source    = target_source,
            antenna_set      = antenna_set,
            frequency_range  = frequency_range,
            start_date       = start_date.tuple(),
            duration_seconds = job_description.duration_seconds,
            station_list     = stations,
            clock_mhz        = clock_mhz,
            subband_spec     = subband_spec))
        start_date = ephem.Date(start_date + ephem.second*job_description.duration_seconds + ephem.second*job_description.gap_seconds)
        previous_clock=clock_mhz
        pass
    return observations
                                
                            




def main(argv):

    job_description = JobDescription(sys.argv, output='lofar-validation-%04d%02d%02d-%02d%02d%02d.xml' % ephem.Observer().date.tuple())
    if job_description.print_help:
        print_manual()
        return -1

    out=open(job_description.output, 'w')
    out.write(as_xml_mom_project(plan_observing_sequence(job_description)))
    out.close()
    
    return 0





if __name__ == '__main__':
    try:
        print_version()
        print 'Current LST: '+str(lofar_current_sidereal_time())
        exit(main(sys.argv))
    except (OSError, IOError) as e:
        prerror(str(e))
        print_short_help()
        exit(-1)
    except (GetoptError, SourceSpecificationError) as e:
        prerror(str(e))
        print_short_help()
        exit(-1)

        
