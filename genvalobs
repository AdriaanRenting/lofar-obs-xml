#!/usr/bin/env python2
# -*- python -*-

import sys, copy
import ephem
import argparse
from momxml import Folder, SourceCatalogue, lofar_sidereal_time
from momxml import Stokes, TiedArrayBeams, BackendProcessing, Beam, Observation
from momxml import exclude_conflicting_eu_stations
from momxml import exclude_conflicting_nl_stations
from momxml import station_list
from momxml import as_xml_mom_project
from momxml import SourceSpecificationError, InvalidStationSetError
from momxml import NoSuitableSourceError
from momxml import __version__


#
# Various messages
#

def prerror(message):
    """
    Print the string in *message* to standard error.
    """
    return sys.stderr.write('genvalobs error: '+message+'\n')


def print_short_help():
    """
    Print a short help message to standard output.
    """
    return sys.stdout.write('genvalobs: use "genvalobs --help" for help\n')



def parse_arguments():
    r'''
    Parse all command line arguments. Uses Python 2.7's argparse module.
    '''
    parser = argparse.ArgumentParser(
        description = r'''
The (optional) source name must be enclosed in single or double
quotes if it contains spaces. The following sources are recommended:

- "3C 48"  /  48: LST 22:30--04:30
- "3C 147" / 147: LST 02:30--08:30
- "3C 196" / 196: LST 05:00--11:00
- "3C 295" / 295: LST 11:00--17:00
- "Cyg A"  / cyg: LST 16:00--24:00

If no source is specified, the program chooses the source that is
closest to the meridian at the central LST of the observing
sequence. The program has separate calibrator lists for LBA
and HBA observations and pulsars.

Although genvalobs has its own default sequence of observations, it is
possible to read a custom set from an ASCII file with a fairly simple
format. The specification consists of newline-separated observations
where each observation is specified in a white-space separated line
with format:

    <ANTENNA_SET> <BAND> <SUBBANDS> <CLOCK> <BIT_MODE> <DATA_PRODUCTS>

    - ANTENNA_SET: one of LBA_INNER, LBA_OUTER, HBA_ZERO, HBA_ONE,
                    HBA_DUAL, HBA_JOINED, HBA_ZERO_INNER,
                    HBA_ONE_INNER, HBA_DUAL_INNER

    - FREQUENCY_BAND: LBA_LOW, LBA_HIGH, HBA_LOW, HBA_MID, HBA_HIGH

    - SUBBAND_LIST: comma-separated list of sub band ranges. Note: NO
                    SPACES ALLOWED! Examples:
                      - 12..499
                      - 12..22,112..122,212..222
    - CLOCK_MHZ: either 200 or 160

    - BIT_MODE: either 4, 8, or 16

    - DATA_PRODUCTS: white-space separated list of products. Allowed:
                     - XC (cross-correlation)
                     - FE (fly's eye)
                     - CS (coherent stokes)
                     - IS (incoherent stokes)
    
    Empty lines are ignored, comments start with # end run until the
    end of the line.
    
    Example file:

        # Antennaset    Band      Subbands   Clock  Bits   Products
        LBA_OUTER       LBA_LOW   12..499    200     8     XC
        HBA_DUAL        HBA_LOW   12..499    200     8     XC
        LBA_INNER       LBA_HIGH  156..399   200    16     FE
        HBA_DUAL        HBA_LOW   77..320    200    16     IS
        HBA_DUAL        HBA_LOW   77..320    200    16     CS
        HBA_DUAL_INNER  HBA_MID   66..309    160    16     XC IS
 
Note that the custom sequence is subject to the same filtering by
options -m, -c, etc. as the default observing sequence. The last entry
is using the 160 MHz clock. It will only be used in the observation
sequence if the 160 MHz is selected using the -c / --clock option.

_
''', 
        formatter_class = argparse.RawDescriptionHelpFormatter)

    #usage='%(prog)s [options] \'source name\'')
    arg = parser.add_argument

    arg('-o', '--output', metavar='FILENAME',
        help    = 'Name of the output file [%(default)s].',
        default = ('lofar-validation-%04d%02d%02d-%02d%02d%02d.xml' %
                   ephem.Observer().date.tuple()))
    
    arg('-m', '--mode', metavar='CORRELATOR_MODE',
        choices = ['XC', 'FE', 'CS', 'IS'], action='append',
        help    = '''
Correlator modes to test. Choose one of XC (crosscorrelation), FE
(Fly\'s eye), IS (incoherent stokes), or CS (coherent stokes). One can
specify more than one mode. If this argument is not spedified, all
modes will be tested [XC,FE,CS,IS].''',
        default = None)

    arg('-d', '--duration', metavar='SECONDS',
        help = 'Duration of individual observations in seconds [%(default)r].',
        type = int, default=120)

    arg('-g', '--gap', metavar='SECONDS',
        help = 'Gap between observations in seconds [%(default)r].',
        type = int, default=60)

    arg('-s', '--stations', metavar='STATION_SET',
        choices = ['superterp', 'core', 'remote', 'nl', 'eu', 'all', 'none'],
        help    = '''
One of superterp, core, remote, nl, eu, all, or none. EU stations
that conflict with certain HBA1 core fields are excluded from the
HBA_ONE, HBA_ONE_INNER, HBA_DUAL, and HBA_DUAL_INNER
observations. They are taken along in all other observations [%(default)s].''',
        default = 'nl')

    arg('-i', '--include', metavar='STATION_NAMES',
        help = 'Comma separated list of station names to include.')
    
    arg('-e', '--exclude', metavar='STATION_NAMES',
        help = 'Comma separated list of station names to exclude.')


    arg('--min-alt', metavar='DEGREES',
        help = 'Minimum elevation for target sources [%(default)5.2f].',
        type = float, default = 45.0)
    
    arg('--max-alt', metavar='DEGREES',
        help = 'Maximum elevation for target sources [%(default)5.2f].',
        type = float, default = 70.0)
    
    arg('-c', '--clocks', metavar='CLOCK_MHZ', action='append',
        choices = [160, 200],
        help    = '''Allowed clock frequencies. Choose 160 or 200. Option can be
provided multiple times if more than one clock frequency is
required.''',
        type=int, default=None)

    arg('-w', '--wait', metavar='SECONDS',
        help = 'Number of seconds to wait until the first observation [%(default)r].',
        type = int, default=540)

    arg('-t', '--start-date', metavar='DATE_STRING',
        help = '''Specify an exact date and time to start the first
        observation. Format: "yyyy/mm/dd hh:mm:ss.s"''')
    
    arg('-p', '--project', metavar='MOM_NAME',
        help    = 'Name of the project under which the observations belong  [%(default)r].',
        default = '2013LOFAROBS')

    arg('-k', '--keep', metavar='CORE_OR_EU',
        help = 'In case of HBA_DUAL or HBA_ONE network conflicts, keep either "core" or "eu" stations [core].',
        default='core', choices=['core', 'eu'])


    arg('-f', '--from-file', metavar='FILE_NAME',
        help='Read a custom observing sequence from FILE_NAME.',
        default = None)

    arg('-v', '--version', action='version',
        version = '%(prog)s ' +__version__+
        ' (c) 2010-2013 M.A. Brentjens <brentjens@astron.nl>',
        help = 'Print version number and exit.')
    
    arg('source', nargs = '?',
        help = '''
Force a source to be used for all observations, bypassing genvalobs\'
own heuristics.''',
        default = None)

    args = parser.parse_args()
    if args.clocks is None:
        args.clocks = [200]

    if args.mode is None:
        args.mode = ['XC', 'FE', 'CS', 'IS']
    args.mode = [mode.upper() for mode in args.mode]
    return  args





def lookup_source(source_name=None):
    """
    Look up *source_name* in a table of standard calibrator
    sources. Raise a SourceSpecificationError if the source is not
    found. Otherwise, return a TargetSource object.
    """
    return SourceCatalogue().find_source(source_name)


def read_custom_observation_sequence(file_contents):
    r'''
    Read a custom scheduled from string ``file_contents``. The
    specification consists of newline-separated observationsm where
    each observation is specified in a white-space separated line with format:

        <ANTENNA_SET>  <FREQUENCY_BAND>  <SUBBAND_LIST>  <CLOCK_MHZ>  <BIT_MODE>  <DATA_PRODUCTS>

    - ANTENNA_SET: one of LBA_INNER, LBA_OUTER, HBA_ZERO, HBA_ONE,
                    HBA_DUAL, HBA_JOINED, HBA_ZERO_INNER,
                    HBA_ONE_INNER, HBA_DUAL_INNER

    - FREQUENCY_BAND: LBA_LOW, LBA_HIGH, HBA_LOW, HBA_MID, HBA_HIGH

    - SUBBAND_LIST: comma-separated list of sub band ranges. Note: NO
                    SPACES ALLOWED! Examples:
                      - 12..499
                      - 12..22,112..122,212..222
    - CLOCK_MHZ: either 200 or 160

    - BIT_MODE: either 4, 8, or 16

    - DATA_PRODUCTS: white-space separated list of products. Allowed:
                     - XC (cross-correlation)
                     - FE (fly's eye)
                     - CS (coherent stokes)
                     - IS (incoherent stokes)
    
    Empty lines are ignored, comments start with # end run until the
    end of the line.
    
    Example file:

        # Antennaset    Band      Subbands   Clock  Bits   Products
        LBA_OUTER       LBA_LOW   12..499    200     8     XC
        HBA_DUAL        HBA_LOW   12..499    200     8     XC
        LBA_INNER       LBA_HIGH  156..399   200    16     FE
        HBA_DUAL        HBA_LOW   77..320    200    16     IS
        HBA_DUAL        HBA_LOW   77..320    200    16     CS
        HBA_DUAL_INNER  HBA_MID   66..309    160    16     XC IS
    
    Note that the last entry is using the 160 MHz clock. It will only be
    used in the observation sequence if the 160 MHz is selected using
    the -c / --clock option. See the genvalobs --help for details.

    **Parameters**
    
    file_contents : string
        Contents of the specification file.

    **Raises**

    ValueError:
        If an error occurs while reading the file.
    
    '''
    lines          = [line.strip() for line in file_contents.split('\n')]
    no_comments    = [line.split('#')[0].strip() for line in lines]
    no_empty_lines = [line.strip() for line in no_comments if line.strip() != '']
    
    valid_antenna_sets = ['LBA_INNER', 'LBA_OUTER',
                          'HBA_ZERO', 'HBA_ONE', 'HBA_DUAL', 'HBA_JOINED',
                          'HBA_ZERO_INNER', 'HBA_ONE_INNER',
                          'HBA_DUAL_INNER']
    valid_bands        = ['LBA_LOW', 'LBA_HIGH', 'HBA_LOW', 'HBA_MID', 'HBA_HIGH']
    valid_clocks       = [160, 200]
    valid_bits         = [4, 8, 16]
    valid_products     = ['XC', 'FE', 'IS', 'CS']

    def record_from_line(line):
        fields = line.split()

        if len(fields) < 6 or len(fields) > 9:
            raise ValueError('Line %r is malformed' % line)

        if fields[0].upper() not in valid_antenna_sets:
            raise ValueError('Antenna set %s not in %r' % (fields[0], valid_antenna_sets))

        if fields[1].upper() not in valid_bands:
            raise ValueError('Band %s not in %r' % (fields[1], valid_bands))

        if int(fields[3]) not in valid_clocks:
            raise ValueError('Clock frequency %r not in %r' % (int(fields[3]), valid_clocks))

        if int(fields[4]) not in valid_bits:
            raise ValueError('Bit mode %r not in %r' % (int(fields[4]), valid_bits))

        for data_product in fields[5:]:
            if data_product.upper() not in valid_products:
                raise ValueError('Data product %r not in %r' %
                                 (data_product, valid_products))

        return [fields[0].upper(),
                fields[1].upper(),
                fields[2],
                int(fields[3]),
                int(fields[4]),
                [field.upper() for field in fields[5:]]]
        
    return [record_from_line(line) for line in no_empty_lines]
    



def plan_observing_sequence(job_description):
    # Possible products:
    #  'XC'             , 'IS'             , 'CS'           , 'FE' for
    #  cross correlation, incoherent stokes, coherent stokes, Fly's eye
    full_schedule = [
        ['LBA_OUTER'     , 'LBA_LOW' , '12..499' , 200,  8, ['XC']],
        ['HBA_DUAL'      , 'HBA_LOW' , '12..499' , 200,  8, ['XC']],
        ['LBA_INNER'     , 'LBA_HIGH', '156..399', 200, 16, ['FE']],
        ['LBA_OUTER'     , 'LBA_HIGH', '156..399', 200, 16, ['FE']],
        ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['FE']],
        ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['IS']],
        ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['CS']],
        ['LBA_INNER'     , 'LBA_LOW' , '54..297' , 200, 16, ['XC']],
        ['LBA_OUTER'     , 'LBA_LOW' , '54..297' , 200, 16, ['XC']],
        ['LBA_INNER'     , 'LBA_HIGH', '156..399', 200, 16, ['XC']],
        ['LBA_OUTER'     , 'LBA_HIGH', '156..399', 200, 16, ['XC']],
        ['HBA_ZERO'      , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_ONE'       , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_DUAL_INNER', 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_JOINED'    , 'HBA_LOW' , '77..320' , 200, 16, ['XC']],
        ['HBA_ZERO'      , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_ONE'       , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_DUAL'      , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_DUAL_INNER', 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_JOINED'    , 'HBA_MID' , '66..309' , 160, 16, ['XC']],
        ['HBA_ZERO'      , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
        ['HBA_ONE'       , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
        ['HBA_DUAL'      , 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
        ['HBA_DUAL_INNER', 'HBA_HIGH', '52..255' , 200, 16, ['XC']],
        ['HBA_JOINED'    , 'HBA_HIGH', '52..255' , 200, 16, ['XC']]]
    print job_description
    if job_description.from_file is not None:
        full_schedule = read_custom_observation_sequence(
            open(job_description.from_file).read())
        print('='*60)
        print('Using custom sequence (%s)' %  job_description.from_file)
        for observation in full_schedule:
            print(observation)
        print('='*60)
    else:
        print('using default sequence')
        
    max_el_deg = job_description.max_alt
    min_el_deg = job_description.min_alt

    schedule      = [obs for obs in full_schedule
                     if obs[3] in job_description.clocks]
    now           = ephem.Observer().date
    start_date    = ephem.Date(now + ephem.second*job_description.wait)
    if job_description.start_date:
        start_date = ephem.Date(job_description.start_date)

    print 'LST at start observation: %s' % str(lofar_sidereal_time(start_date))

    mean_date     = (start_date +
                     ephem.second*len(schedule)*(job_description.duration +
                                                 job_description.gap)*0.5)

    mean_lst      = lofar_sidereal_time(mean_date)
    print 'Mean date: ' + repr(mean_date)
    print 'Mean LST: '+str(mean_lst)
    print 'Mean LST rad: %f' % float(mean_lst)

    include       = job_description.include
    include       = include and include.split(',')
    exclude       = job_description.exclude
    exclude       = exclude and exclude.split(',')
    stations      = station_list(job_description.stations,
                                 include = include,
                                 exclude = exclude,)
    observations  = []
    previous_clock = 200
    for (antenna_set,
         frequency_range,
         subband_spec,
         clock_mhz,
         bit_mode,
         data_products) in schedule:
        station_set   = copy.deepcopy(stations)
        target_source = job_description.source
        data_products = [data_product
                         for data_product in data_products
                         if data_product in job_description.mode]

        if len(data_products) == 0:
            continue # No data products to write, no point to observe.
        if target_source is None:
            if ('FE' in data_products 
                or 'CS' in data_products 
                or 'IS' in data_products):
                target_source = SourceCatalogue().psr_source(
                    mean_date, antenna_set[0:3],
                    min_elevation_deg = min_el_deg,
                    max_elevation_deg = max_el_deg)
            else:
                if frequency_range[0:3] == 'LBA':
                    target_source = SourceCatalogue().cal_source(
                        mean_date, antenna_set[0:3])
                else:
                    target_source = SourceCatalogue().cal_source(
                        mean_date, antenna_set[0:3],
                        min_elevation_deg = min_el_deg,
                        max_elevation_deg = max_el_deg)
        else:
            target_source = lookup_source(target_source)

        print ','.join(data_products) + ' ' + antenna_set
        print target_source
        # If clock switches, allow for two minutes extra
        if previous_clock != clock_mhz: 
            start_date = ephem.Date(start_date + 2*ephem.minute)

        channels_per_subband   = 64
        coherent_stokes_data   = None
        incoherent_stokes_data = None
        tied_array_beams       = None
        duration_seconds       = job_description.duration
        if 'FE' in data_products:
            channels_per_subband = 16
            coherent_stokes_data = Stokes('coherent',
                                          stokes_downsampling_steps = 128)
            tied_array_beams     = TiedArrayBeams(flyseye      = True,
                                                  beam_offsets = None)
            if 'LBA' == antenna_set[0:3]:
                duration_seconds = 600.0
        if 'CS' in data_products:
            coherent_stokes_data = Stokes('coherent',
                                          stokes_downsampling_steps = 128)
            if tied_array_beams is None:
                tied_array_beams = TiedArrayBeams(flyseye      = False,
                                                  beam_offsets = [(0.0, 0.0)])
            else:
                tied_array_beams.beam_offsets = [(0.0, 0.0)]
            core = set(station_list('core'))
            station_set = set(station_set).intersection(core)
        if 'IS' in data_products:
            incoherent_stokes_data = Stokes('incoherent',
                                            stokes_downsampling_steps = 128)
            
        good_stations = sorted(list(station_set))
        antenna_sets_with_conflicts = [
            'HBA_ONE', 'HBA_DUAL', 'HBA_ONE_INNER', 'HBA_DUAL_INNER']
        if antenna_set in antenna_sets_with_conflicts:
            if 'core' == job_description.keep:
                good_stations = exclude_conflicting_eu_stations(good_stations)
            elif 'eu' == job_description.keep:
                good_stations = exclude_conflicting_nl_stations(good_stations)
            else:
                raise RuntimeError('%s stations are not known to conflict. Use either core or eu' %  job_description.keep)

        backend = BackendProcessing(
            integration_time_seconds = 1,
            correlated_data          = 'XC' in data_products,
            channels_per_subband     = channels_per_subband,
            coherent_stokes_data     = coherent_stokes_data,
            incoherent_stokes_data   = incoherent_stokes_data,
            tied_array_beams         = tied_array_beams)
        
        observations.append(Observation(
            name                     = ','.join(data_products)+' '+antenna_set,
            antenna_set              = antenna_set,
            frequency_range          = frequency_range,
            start_date               = start_date.tuple(),
            duration_seconds         = duration_seconds,
            stations                 = good_stations,
            clock_mhz                = clock_mhz,
            backend                  = backend,
            bit_mode                 = bit_mode,
            beam_list=[Beam(
                target_source            = target_source,
                subband_spec             = subband_spec)]))
        start_date = ephem.Date(start_date
                                + ephem.second*duration_seconds
                                + ephem.second*job_description.gap)
        previous_clock = clock_mhz
    return observations






def main():
    print parse_arguments()
    job_description = parse_arguments()

    observations = plan_observing_sequence(job_description)
    folder_date  = observations[0].start_date
    
    sub_folder     = Folder(
        name        =  '%04d-%02d-%02d %02d:%02d' % folder_date[:-1],
        description = ('Validation observations %04d-%02d-%02d %02d:%02d' %
                       folder_date[:-1]),
        children    = observations,
        grouping_parent = True,
        label           = '0')
    val_obs_folder = Folder(name     = 'Validation Obs',
                            mom_id   = 192732,
                            children = [sub_folder])
    out = open(job_description.output, 'w')
    out.write(xml([val_obs_folder],
                  project = job_description.project))
    out.close()

    return 0





if __name__ == '__main__':
    try:
        print 'Current LST: '+str(lofar_sidereal_time(ephem.Observer().date))
        exit(main())
    except (OSError, IOError, SourceSpecificationError, InvalidStationSetError, NoSuitableSourceError):
        prerror(sys.exc_info()[1].args[0])
        print_short_help()
        exit(-1)
