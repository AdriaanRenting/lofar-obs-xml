#!/usr/bin/env python2
# -*- python -*-

import os, sys
from getopt import gnu_getopt as getopt
from getopt import GetoptError
import ephem
from math import pi
from momxml import *
from momxml import __version__

#
# Various messages
#


def print_version():
    """
    Print version info to standard output
    """
    return sys.stdout.write('genvalobs version %s (c) 2010-2012 Michiel Brentjens <brentjens@astron.nl>\n' % __version__)


def prerror(message):
    """
    Print the string in *message* to standard error.
    """
    return sys.stderr.write('genvalobs error: '+message+'\n')


def print_short_help():
    """
    Print a short help message to standard output.
    """
    return sys.stdout.write('genvalobs: use "genvalobs --help" for help\n')


def print_manual():
    """
    Print basic manual to standard output.
    """
    return sys.stdout.write("""
usage: genvalobs [options] \"source name\"

The source name must be enclosed in single or double quotes if it
contains spaces. The following sources are recommended:

- \"3C 48\"  /  48: LST 22:30--04:30
- \"3C 147\" / 147: LST 02:30--08:30
- \"3C 196\" / 196: LST 05:00--11:00
- \"3C 295\" / 295: LST 11:00--17:00
- \"Cyg A\"  / cyg: LST 16:00--24:00

If no source is specified, the program chooses the source that is
closest to the meridian at the central LST of the observing
sequence. The program has separate calibrator lists for LBA and HBA
observations.

Options:
-o / --output     Name of the output file. Default is
                  lofar-validation-yyyymmdd-hhmmss.xml

-d / --duration   Duration of individual observations in
                  seconds. Default is 120.

-g / --gap        Gap between observations in seconds. Default
                  is 60.

-c / --clocks     Comma separated list of allowed clock frequencies
                  in MHz. Default is 200. Other example: -c 160,200.

-s / --stations   Station set. One of: superterp, core, remote, nl,
                  europe, all, or none. Default is nl. EU stations
                  that conflict with certain HBA1 core fields are
                  excluded from the HBA_ONE, HBA_ONE_INNER, HBA_DUAL,
                  and HBA_DUAL_INNER observations. They are taken
                  along in all other observations.

-i / --include    Comma separated list of station names to add to
                  station set.

-e / --exclude    Comma separated list of stations to exlude from
                  station set.

-w / --wait       Number of seconds to wait before the first observation
                  must begin. Default is 540 seconds.

-t / --start-date Specify an exact date and time to start the first
                  observation. Format: "yyyy/mm/dd hh:mm:ss.s"

-p / --project    Name of the project under which the observations
                  belong. Default: '2013LOFAROBS'

-h / --help       Display manual.

""")



def lookup_source(source_name=None):
    """
    Look up *source_name* in a table of standard calibrator
    sources. Raise a SourceSpecificationError if the source is not
    found. Otherwise, return a TargetSource object.
    """
    return SourceCatalogue().find_source(source_name)










#
#  JobDescription
#

class JobDescription:
    """
    The JobDescription class is responsible for commandline
    parsing. Its data members are the program settings. One can
    specify default values when the object is constructed. Example
    usage:

    >>> job = JobDescription(sys.argv, duration=200)
    """

    def __init__(self, argv, output = 'schedule.log', wait_seconds = 540,
                 duration_seconds = 120, gap_seconds=60, target_source = None,
                 allowed_clocks_mhz = [200], print_help = False,
                 station_set = 'nl', include_list = [], exclude_list = [],
                 start_date = None, project='2013LOFAROBS'):
        """
        Set default values and call parse_commandline(argv)
        """
        self.output                = output
        self.wait_seconds          = wait_seconds
        self.duration_seconds      = duration_seconds
        self.gap_seconds           = gap_seconds
        self.target_source         = target_source
        self.allowed_clocks_mhz    = allowed_clocks_mhz
        self.print_help            = print_help
        self.station_set           = station_set
        self.exclude_list          = exclude_list
        self.include_list          = include_list
        self.start_date            = start_date
        self.project               = project
        self.parse_commandline(argv)
        pass


    def parse_commandline(self, argv):
        """
        Parse the commandline passed in *argv*. Returns reference to
        self. May raise a GetoptError in case of commandline parsing
        problems.
        """
        options, args = getopt(argv[1:], 'o:d:i:e:s:g:w:hc:vt:p:',
                               ['output=',
                                'duration=',
                                'clocks=',
                                'include=',
                                'exclude=',
                                'stations=',
                                'gap=',
                                'wait=',
                                'start-date=',
                                'project=',
                                'help',
                                'version'])
        for (option, value) in options:
            if option in ['-v', '--version']:
                exit(0)
            if option in ['-o', '--output']:
                self.output = value

            elif option in ['-w', '--wait']:
                try:
                    self.wait_seconds = int(value)
                except (ValueError,):
                    raise GetoptError('Wait time must be an integer in seconds.\nYou specified: "%s"' % (value,))


            elif option in ['-d', '--duration']:
                try:
                    self.duration_seconds = int(value)
                except (ValueError,):
                    raise GetoptError('Duration must be an integer in seconds.\nYou specified: "%s"' % (value,))

            elif option in ['-c', '--clocks']:
                self.allowed_clocks_mhz = [int(clock) for clock in value.split(',')]
                for clock in self.allowed_clocks_mhz:
                    if clock not in [160, 200]:
                        raise GetoptError('Allowed clocks are 160 and 200, not %d' % clock)


            elif option in ['-g', '--gap']:
                try:
                    self.gap_seconds = int(value)
                except (ValueError,):
                    raise GetoptError('Gap must be an integer in seconds.\nYou specified: "%s"' % (value,))


            elif  option in ['-s', '--stations']:
                self.station_set = value

            elif  option in ['-i', '--include']:
                self.include_list = value.upper().split(',')

            elif  option in ['-e', '--exclude']:
                self.exclude_list = value.upper().split(',')

            elif option in ['-t', '--start-date']:
                self.start_date = ephem.Date(value)

            elif option in ['-p', '--project']:
                self.project = value

            elif option in ['-h', '--help']:
                self.print_help = True
                return self
            pass # end of for loop

        if len(args) > 1:
            raise GetoptError('Although you may specify at most 1 target source, you specified %d, namely %s'%(len(args), str(args)))
        elif len(args) == 1:
            self.target_source = lookup_source(args[0])
        else:
            self.target_source = None
        return self


def plan_observing_sequence(job_description):
    # Possible products:
    #  'XC', 'IS', 'CS', 'FE' for cross cor, incoherent stokes, coherent stokes, Fly's eye
    full_schedule = [['LBA_OUTER'     , 'LBA_LOW' , '12..499' , 200,  8, 'XC'],
                     ['HBA_DUAL'      , 'HBA_LOW' , '12..499' , 200,  8, 'XC'],
                     ['LBA_INNER'     , 'LBA_HIGH', '156..399', 200, 16, 'FE'],
                     ['LBA_OUTER'     , 'LBA_HIGH', '156..399', 200, 16, 'FE'],
                     ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, 'FE'],
                     ['LBA_INNER'     , 'LBA_LOW' , '54..297' , 200, 16, 'XC'],
                     ['LBA_OUTER'     , 'LBA_LOW' , '54..297' , 200, 16, 'XC'],
                     ['LBA_INNER'     , 'LBA_HIGH', '156..399', 200, 16, 'XC'],
                     ['LBA_OUTER'     , 'LBA_HIGH', '156..399', 200, 16, 'XC'],
                     ['HBA_ZERO'      , 'HBA_LOW' , '77..320' , 200, 16, 'XC'],
                     ['HBA_ONE'       , 'HBA_LOW' , '77..320' , 200, 16, 'XC'],
                     ['HBA_DUAL'      , 'HBA_LOW' , '77..320' , 200, 16, 'XC'],
                     ['HBA_DUAL_INNER', 'HBA_LOW' , '77..320' , 200, 16, 'XC'],
                     ['HBA_JOINED'    , 'HBA_LOW' , '77..320' , 200, 16, 'XC'],
                     ['HBA_ZERO'      , 'HBA_MID' , '66..309' , 160, 16, 'XC'],
                     ['HBA_ONE'       , 'HBA_MID' , '66..309' , 160, 16, 'XC'],
                     ['HBA_DUAL'      , 'HBA_MID' , '66..309' , 160, 16, 'XC'],
                     ['HBA_DUAL_INNER', 'HBA_MID' , '66..309' , 160, 16, 'XC'],
                     ['HBA_JOINED'    , 'HBA_MID' , '66..309' , 160, 16, 'XC'],
                     ['HBA_ZERO'      , 'HBA_HIGH', '52..255' , 200, 16, 'XC'],
                     ['HBA_ONE'       , 'HBA_HIGH', '52..255' , 200, 16, 'XC'],
                     ['HBA_DUAL'      , 'HBA_HIGH', '52..255' , 200, 16, 'XC'],
                     ['HBA_DUAL_INNER', 'HBA_HIGH', '52..255' , 200, 16, 'XC'],
                     ['HBA_JOINED'    , 'HBA_HIGH', '52..255' , 200, 16, 'XC']
                     ]
    print job_description.allowed_clocks_mhz
    print job_description.wait_seconds

    schedule      = [obs for obs in full_schedule if obs[3] in job_description.allowed_clocks_mhz]
    now           = ephem.Observer().date
    start_date    = ephem.Date(now + ephem.second*job_description.wait_seconds)
    if job_description.start_date:
        start_date = job_description.start_date

    print 'LST at start observation: %s' % str(lofar_sidereal_time(start_date))

    mean_date     = (start_date +
                     ephem.second*len(schedule)*(job_description.duration_seconds +
                                                 job_description.gap_seconds)*0.5)

    mean_lst      = lofar_sidereal_time(mean_date)
    print 'Mean date: ' + repr(mean_date)
    print 'Mean LST: '+str(mean_lst)
    print 'Mean LST rad: %f' % float(mean_lst)

    stations      = station_list(job_description.station_set,
                                 include = job_description.include_list,
                                 exclude = job_description.exclude_list)
    observations  = []
    previous_clock=200
    for antenna_set, frequency_range, subband_spec, clock_mhz, bit_mode, data_products in schedule:
        target_source = job_description.target_source
        if target_source is None:
            if 'FE' in data_products or 'CS' in data_products or 'IS' in data_products:
                target_source = SourceCatalogue().psr_source(mean_date, antenna_set[0:3])
            else:
                target_source = SourceCatalogue().cal_source(mean_date, antenna_set[0:3])
        print data_products + ' ' + antenna_set
        print target_source
        if previous_clock != clock_mhz: # If clock switches, allow for two minutes extra
            start_date = ephem.Date(start_date + 2*ephem.minute)
        good_stations = stations
        if antenna_set in ['HBA_ONE', 'HBA_DUAL', 'HBA_ONE_INNER', 'HBA_DUAL_INNER']:
            good_stations = exclude_conflicting_eu_stations(good_stations)

        channels_per_subband = 64
        coherent_stokes_data = None
        tied_array_beams     = None
        duration_seconds     = job_description.duration_seconds
        if 'FE' in data_products:
            channels_per_subband = 16
            coherent_stokes_data = Stokes('coherent',
                                          stokes_downsampling_steps = 64)
            tied_array_beams     = TiedArrayBeams(flyseye = True, beam_offsets=[(0.0, 0.0)])
            if 'LBA' == antenna_set[0:3]:
                duration_seconds = 300.0


        backend = BackendProcessing(
            integration_time_seconds = 1,
            correlated_data          = 'XC' in data_products,
            channels_per_subband     = channels_per_subband,
            coherent_stokes_data     = coherent_stokes_data,
            tied_array_beams         = tied_array_beams)

        observations.append(Observation(
            name                     = data_products + ' ' + antenna_set,
            antenna_set              = antenna_set,
            frequency_range          = frequency_range,
            start_date               = start_date.tuple(),
            duration_seconds         = duration_seconds,
            stations                 = good_stations,
            clock_mhz                = clock_mhz,
            backend                  = backend,
            bit_mode                 = bit_mode,
            beam_list=[Beam(
                target_source            = target_source,
                subband_spec             = subband_spec)]))
        start_date = ephem.Date(start_date
                                + ephem.second*duration_seconds
                                + ephem.second*job_description.gap_seconds)
        previous_clock=clock_mhz
        pass
    return observations






def main(argv):

    job_description = JobDescription(sys.argv, output='lofar-validation-%04d%02d%02d-%02d%02d%02d.xml' % ephem.Observer().date.tuple())
    if job_description.print_help:
        print_manual()
        return -1

    observations = plan_observing_sequence(job_description)
    folder_date  = observations[0].start_date
    
    sub_folder     = Folder(name =  '%04d-%02d-%02d %02d:%02d' % folder_date[:-1],
                            description = 'Validation observations %04d-%02d-%02d %02d:%02d' % folder_date[:-1],
                            children    = observations)
    val_obs_folder = Folder(name = 'Validation Obs', mom_id=192732,
                            children = [sub_folder])
    out=open(job_description.output, 'w')
    out.write(as_xml_mom_project([val_obs_folder], project=job_description.project))
    out.close()

    return 0





if __name__ == '__main__':
    try:
        print_version()
        print 'Current LST: '+str(lofar_sidereal_time(ephem.Observer().date))
        exit(main(sys.argv))
    except (OSError, IOError, GetoptError, SourceSpecificationError, InvalidStationSetError):
        prerror(sys.exc_info()[1].args[0])
        print_short_help()
        exit(-1)
